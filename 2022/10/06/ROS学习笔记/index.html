<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>ROS学习笔记 | Karson Kang</title><meta name="keywords" content="-ROS -Ubuntu"><meta name="author" content="Karson Kang"><meta name="copyright" content="Karson Kang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这个文档用于ROS的学习记录">
<meta property="og:type" content="article">
<meta property="og:title" content="ROS学习笔记">
<meta property="og:url" content="http://karsonkang.github.io/2022/10/06/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Karson Kang">
<meta property="og:description" content="这个文档用于ROS的学习记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://karsonkang.github.io/img/ROS-noetic.png">
<meta property="article:published_time" content="2022-10-06T11:17:11.000Z">
<meta property="article:modified_time" content="2023-02-10T05:53:00.101Z">
<meta property="article:author" content="Karson Kang">
<meta property="article:tag" content="-ROS -Ubuntu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://karsonkang.github.io/img/ROS-noetic.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://karsonkang.github.io/2022/10/06/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: Karson Kang","link":"链接: ","source":"来源: Karson Kang","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ROS学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-10 14:53:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/Avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/ROS-noetic.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Karson Kang</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ROS学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-06T11:17:11.000Z" title="发表于 2022-10-06 20:17:11">2022-10-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-10T05:53:00.101Z" title="更新于 2023-02-10 14:53:00">2023-02-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ROS学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>笔记内容源自视频整理<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ci4y1L7ZZ?p=19&vd_source=cec275bb24eee5a4c935b9eb86182012">Autolabor课程</a>,<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hd4y1X75p/?spm_id_from=333.337.search-card.all.click&vd_source=cec275bb24eee5a4c935b9eb86182012">机器人工匠阿杰</a>,和<a target="_blank" rel="noopener" href="http://www.autolabor.com.cn/book/ROSTutorials/">Autolabor课程文件</a>。</p>
<h1 id="Ubuntu终端窗口命令"><a href="#Ubuntu终端窗口命令" class="headerlink" title="Ubuntu终端窗口命令"></a>Ubuntu终端窗口命令</h1><h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd 文件夹名/路径名  //进入当前目录的某个文件夹，或进入某个路径的文件夹</span><br><span class="line"></span><br><span class="line">cd ..   //返回上一级目录</span><br><span class="line"></span><br><span class="line">cd ~    //返回/home挂载点</span><br><span class="line"></span><br><span class="line">ls      //列出当前所在文件夹的目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在输入命令式要熟练使用Tab键，自动补全文件名</p>
<h2 id="文本编辑器gedit"><a href="#文本编辑器gedit" class="headerlink" title="文本编辑器gedit"></a>文本编辑器gedit</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gedit 文件名.文件格式(例如.txt)    //在当前路径下新建一个文本文件</span><br><span class="line"></span><br><span class="line">gedit command.sh    //生成一个command的可执行文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="source指令"><a href="#source指令" class="headerlink" title="source指令"></a>source指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source command.sh   //在Linux中常常吧一连串的指令写到.sh文件中，通过source指令加载运行</span><br></pre></td></tr></table></figure>

<h2 id="终端程启动脚本-x2F-bashrc"><a href="#终端程启动脚本-x2F-bashrc" class="headerlink" title="终端程启动脚本 ~&#x2F;.bashrc"></a>终端程启动脚本 ~&#x2F;.bashrc</h2><p>这是一个在主文件夹中的隐藏文件，在文件管理器中看不到，可以通过在终端中输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a   //查看所有文件，包括隐藏文件</span><br></pre></td></tr></table></figure>
<p>.bashrc文件是终端程序的初始化脚本，在每次执行终端程序时，都会首先执行这个脚本，进行环境变量的配置工作。通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>对脚本进行编辑，如下图<br><img src="/./img/ROSpictures/bashrc%E6%88%AA%E5%9B%BE.png" alt="bashrc窗口截图"></p>
<h2 id="sudo指令"><a href="#sudo指令" class="headerlink" title="sudo指令"></a>sudo指令</h2><p>以管理员权限执行本条执行，可以让我们完成安装等高权限操作。<br>比如，安装文件时可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install 文件名</span><br></pre></td></tr></table></figure>
<p>实现文件的安装操作</p>
<h1 id="ROS系统"><a href="#ROS系统" class="headerlink" title="ROS系统"></a>ROS系统</h1><h2 id="ROS安装步骤"><a href="#ROS安装步骤" class="headerlink" title="ROS安装步骤"></a>ROS安装步骤</h2><ol>
<li>首先进入ROS官网<strong><a target="_blank" rel="noopener" href="https://www.ros.org/">https://www.ros.org</a></strong>。</li>
<li>选择与Ubuntu系统版本对应的ROS系统名称，例如我安装的是Ubuntu20.04版本，对应的ROS系统名称叫Noetic。</li>
<li>根据官网的步骤，首先在终端程序中输入指令，完成相关配置。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span><br></pre></td></tr></table></figure>
 可以通过选择国内的安装镜像，加快安装速度。</li>
<li>设置安装秘钥 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install curl # if you haven&#x27;t already installed curl</span><br><span class="line"></span><br><span class="line">curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -</span><br></pre></td></tr></table></figure>
 如果网络波动较大，可能会出现安装失败的问题。</li>
<li>下载安装ROS主体程序<ol>
<li>运行<code>sudo apt update</code>从网上的各大应用商店更新APP索引列表。</li>
<li>从更新后的索引列表中安装ROS系统<code>sudo apt install ros-noetic-desktop-full</code>。</li>
</ol>
</li>
<li>环境参数设置<br>在新的终端中输入 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
 之后输入<code>roscore</code>检查ROS的核心是否可以运行。</li>
<li>最后对ROS的依赖包工具进行初始化，方便我们安装第三方的扩展软件包。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential</span><br><span class="line"></span><br><span class="line">sudo rosdep init</span><br><span class="line"></span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure>
 到这儿就基本完成安装了，如果出现了无法解决的问题，可以在B站上搜索<strong>机器人工匠阿杰</strong>观看详细视频。</li>
</ol>
<h2 id="APT源，ROS的软件包应用商店"><a href="#APT源，ROS的软件包应用商店" class="headerlink" title="APT源，ROS的软件包应用商店"></a>APT源，ROS的软件包应用商店</h2><p>在浏览器中输入<strong>index.ros.org</strong>，可以在这里下载到ROS的软件包，资源库。</p>
<h2 id="ROS架构"><a href="#ROS架构" class="headerlink" title="ROS架构"></a>ROS架构</h2><p>ROS文件系统指的是在硬盘上ROS源代码的组织形式，其大致结构如下：<br><img src="/./img/ROSpictures/ROS%E6%96%87%E4%BB%B6%E7%BB%84%E6%88%90.png" alt="ROS文件系统结构"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">WorkSpace --- 自定义的工作空间</span><br><span class="line"></span><br><span class="line">    |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。</span><br><span class="line"></span><br><span class="line">    |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态&amp;静态链接库、可执行文件等。</span><br><span class="line"></span><br><span class="line">    |--- src: 源码</span><br><span class="line"></span><br><span class="line">        |-- package：功能包(ROS基本单元)包含多个节点、库与配置文件，包名所有字母小写，只能由字母、数字与下划线组成</span><br><span class="line"></span><br><span class="line">            |-- CMakeLists.txt 配置编译规则，比如源文件、依赖项、目标文件</span><br><span class="line"></span><br><span class="line">            |-- package.xml 包信息，比如:包名、版本、作者、依赖项...(以前版本是 manifest.xml)</span><br><span class="line"></span><br><span class="line">            |-- scripts 存储python文件</span><br><span class="line"></span><br><span class="line">            |-- src 存储C++源文件</span><br><span class="line"></span><br><span class="line">            |-- include 头文件</span><br><span class="line"></span><br><span class="line">            |-- msg 消息通信格式文件</span><br><span class="line"></span><br><span class="line">            |-- srv 服务通信格式文件</span><br><span class="line"></span><br><span class="line">            |-- action 动作格式文件</span><br><span class="line"></span><br><span class="line">            |-- launch 可一次性运行多个节点 </span><br><span class="line"></span><br><span class="line">            |-- config 配置信息</span><br><span class="line"></span><br><span class="line">        |-- CMakeLists.txt: 编译的基本配置</span><br></pre></td></tr></table></figure>
<p>值得注意的点是，在package目录下的scripts目录下写py文件，在scr目录下写C++文件，launch目录下写launch文件。之后主要介绍package.xml文件和CMakeList.txt两个配置文件。</p>
<ol>
<li><p>package.xml</p>
<p> 该文件定义有关软件包的属性，比如软件包的名称，版本号，作者，维护者以及对其他catkin软件包的依赖信息等。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">​&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!-- 格式: 以前是 1，推荐使用格式 2 --&gt;</span><br><span class="line">&lt;package format=&quot;2&quot;&gt;</span><br><span class="line">    &lt;!-- 包名 --&gt;</span><br><span class="line">    &lt;name&gt;demo01_hello_vscode&lt;/name&gt;</span><br><span class="line">    &lt;!-- 版本 --&gt;</span><br><span class="line">    &lt;version&gt;0.0.0&lt;/version&gt;</span><br><span class="line">    &lt;!-- 描述信息 --&gt;</span><br><span class="line">    &lt;description&gt;The demo01_hello_vscode package&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- One maintainer tag required, multiple allowed, one person per tag --&gt;</span><br><span class="line">    &lt;!-- Example:  --&gt;</span><br><span class="line">    &lt;!-- &lt;maintainer email=&quot;jane.doe@example.com&quot;&gt;Jane Doe&lt;/maintainer&gt; --&gt;</span><br><span class="line">    &lt;!-- 维护人员 --&gt;</span><br><span class="line">    &lt;maintainer email=&quot;xuzuo@todo.todo&quot;&gt;xuzuo&lt;/maintainer&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- One license tag required, multiple allowed, one license per tag --&gt;</span><br><span class="line">    &lt;!-- Commonly used license strings: --&gt;</span><br><span class="line">    &lt;!--   BSD, MIT, Boost Software License, GPLv2, GPLv3, LGPLv2.1, LGPLv3 --&gt;</span><br><span class="line">    &lt;!-- 许可证信息，ROS核心组件默认 BSD --&gt;</span><br><span class="line">    &lt;license&gt;TODO&lt;/license&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- Url tags are optional, but multiple are allowed, one per tag --&gt;</span><br><span class="line">    &lt;!-- Optional attribute type can be: website, bugtracker, or repository --&gt;</span><br><span class="line">    &lt;!-- Example: --&gt;</span><br><span class="line">    &lt;!-- &lt;url type=&quot;website&quot;&gt;http://wiki.ros.org/demo01_hello_vscode&lt;/url&gt; --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- Author tags are optional, multiple are allowed, one per tag --&gt;</span><br><span class="line">    &lt;!-- Authors do not have to be maintainers, but could be --&gt;</span><br><span class="line">    &lt;!-- Example: --&gt;</span><br><span class="line">    &lt;!-- &lt;author email=&quot;jane.doe@example.com&quot;&gt;Jane Doe&lt;/author&gt; --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- The *depend tags are used to specify dependencies --&gt;</span><br><span class="line">    &lt;!-- Dependencies can be catkin packages or system dependencies --&gt;</span><br><span class="line">    &lt;!-- Examples: --&gt;</span><br><span class="line">    &lt;!-- Use depend as a shortcut for packages that are both build and exec dependencies --&gt;</span><br><span class="line">    &lt;!--   &lt;depend&gt;roscpp&lt;/depend&gt; --&gt;</span><br><span class="line">    &lt;!--   Note that this is equivalent to the following: --&gt;</span><br><span class="line">    &lt;!--   &lt;build_depend&gt;roscpp&lt;/build_depend&gt; --&gt;</span><br><span class="line">    &lt;!--   &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt; --&gt;</span><br><span class="line">    &lt;!-- Use build_depend for packages you need at compile time: --&gt;</span><br><span class="line">    &lt;!--   &lt;build_depend&gt;message_generation&lt;/build_depend&gt; --&gt;</span><br><span class="line">    &lt;!-- Use build_export_depend for packages you need in order to build against this package: --&gt;</span><br><span class="line">    &lt;!--   &lt;build_export_depend&gt;message_generation&lt;/build_export_depend&gt; --&gt;</span><br><span class="line">    &lt;!-- Use buildtool_depend for build tool packages: --&gt;</span><br><span class="line">    &lt;!--   &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt; --&gt;</span><br><span class="line">    &lt;!-- Use exec_depend for packages you need at runtime: --&gt;</span><br><span class="line">    &lt;!--   &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; --&gt;</span><br><span class="line">    &lt;!-- Use test_depend for packages you need only for testing: --&gt;</span><br><span class="line">    &lt;!--   &lt;test_depend&gt;gtest&lt;/test_depend&gt; --&gt;</span><br><span class="line">    &lt;!-- Use doc_depend for packages you need only for building documentation: --&gt;</span><br><span class="line">    &lt;!--   &lt;doc_depend&gt;doxygen&lt;/doc_depend&gt; --&gt;</span><br><span class="line">    &lt;!-- 依赖的构建工具，这是必须的 --&gt;</span><br><span class="line">    &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 指定构建此软件包所需的软件包 --&gt;</span><br><span class="line">    &lt;build_depend&gt;roscpp&lt;/build_depend&gt;</span><br><span class="line">    &lt;build_depend&gt;rospy&lt;/build_depend&gt;</span><br><span class="line">    &lt;build_depend&gt;std_msgs&lt;/build_depend&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 指定根据这个包构建库所需要的包 --&gt;</span><br><span class="line">    &lt;build_export_depend&gt;roscpp&lt;/build_export_depend&gt;</span><br><span class="line">    &lt;build_export_depend&gt;rospy&lt;/build_export_depend&gt;</span><br><span class="line">    &lt;build_export_depend&gt;std_msgs&lt;/build_export_depend&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 运行该程序包中的代码所需的程序包 --&gt;  </span><br><span class="line">    &lt;exec_depend&gt;roscpp&lt;/exec_depend&gt;</span><br><span class="line">    &lt;exec_depend&gt;rospy&lt;/exec_depend&gt;</span><br><span class="line">    &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- The export tag contains other, unspecified, tags --&gt;</span><br><span class="line">    &lt;export&gt;</span><br><span class="line">        &lt;!-- Other tools can request additional information be placed here --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/export&gt;</span><br><span class="line">&lt;/package&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>CMakelists.txt</p>
<p> 文件CMakeLists.txt是CMake构建系统的输入，用于构建软件包。任何兼容CMake的软件包都包含一个或多个CMakeLists.txt文件，这些文件描述了如何构建代码以及将代码安装到何处。在编写ROS节点，话题等信息时，需要设置CMakelists.txt文件。具体的编写方法，可以观看<strong>机器人工匠阿杰</strong>或<strong>Autolabor初级教程</strong>，了解详细编写方法。</p>
</li>
</ol>
<h2 id="ROS文件系统相关命令"><a href="#ROS文件系统相关命令" class="headerlink" title="ROS文件系统相关命令"></a>ROS文件系统相关命令</h2><p>ROS文件系统本质上是操作系统文件，其本身提供了一些类似于Linux的命令。文件操作，就是增，删，改，查，执行，等5大主要操作。</p>
<ol>
<li>增 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg 自定义包名 依赖包     //创建新的ROS包</span><br><span class="line">sudo apt install xxx    //安装ROS功能包</span><br></pre></td></tr></table></figure></li>
<li>删 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt perge xxx      //删除某个功能包</span><br></pre></td></tr></table></figure></li>
<li>改<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosed 包名 文件名       //修改功能包文件</span><br><span class="line">需要安装vim</span><br><span class="line">比如：rosed turtlesim Color.msg</span><br></pre></td></tr></table></figure></li>
<li>查<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rospack list        //列出所有功能包</span><br><span class="line">rospack find 包名   //查找某个功能包是否存在，如果存在返回安装路径</span><br><span class="line">roscd 包名          //进入某个功能包</span><br><span class="line">rosls 包名          //列出某个包下的文件</span><br><span class="line">apt search xxx      //搜索某个功能包</span><br></pre></td></tr></table></figure></li>
<li>执行<ol>
<li>roscore 这是ROS系统先决条件结点和程序的集合，必须在运行roscore之后才能使节点之间进行通信。roscore会启动 ros master, ros 参数服务器, rosout日志节点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roscore     //启动ros</span><br><span class="line">roscore -p xxx  //指定端口号</span><br></pre></td></tr></table></figure></li>
<li>rosrun 运行指定的ROS节点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosrun 包名 可执行文件名</span><br><span class="line">rosrun turtlesim turtlesim_node     //运行turtlesim包中的可执行文件turtlesim_node</span><br></pre></td></tr></table></figure></li>
<li>roslaunch 执行某个包下的launch文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch 包名 launch文件名     //执行某个包下的某个launch文件</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="ROS计算图rqt-graph"><a href="#ROS计算图rqt-graph" class="headerlink" title="ROS计算图rqt_graph"></a>ROS计算图rqt_graph</h2><p>在一个庞大的ros程序中，不同节点之间的通信非常复杂，ROS中提供了一个实用的工具：rqt_graph，可以显示当前系统运行的情况，各节点之间的通信过程。rqt_grah是rqt程序包中的一部分，在不同版本的ROS中，rqt程序包可能需要手动安装。比如，在Noetic版本下，安装输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-rqt</span><br><span class="line">sudo apt install ros-noetic-rqt-common-plugins</span><br></pre></td></tr></table></figure>
<p>在运行ros节点后，在新的终端中键入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rqt_graph</span><br><span class="line">//或</span><br><span class="line">rosrun rqt_graph rqt_graph</span><br></pre></td></tr></table></figure>
<p>可以看到不同节点之间的关系。<br><img src="/./img/ROSpictures/rqt_graph.png" alt="rqt_graph图"></p>
<h1 id="ROS通信机制"><a href="#ROS通信机制" class="headerlink" title="ROS通信机制"></a>ROS通信机制</h1><p>在机器人中，可能集成各种传感器（摄像头，雷达等），在ROS中，每个功能点都是一个单独的进程，每个进程都是独立运行的，可以认为ROS进程（也叫Nodes，节点）的分布式框架。这些进程分布于不同的主机，不同主机协同工作，从而分散计算压力。但是随之而来的问题是，不同进程之间如何进行通信。</p>
<p>ROS中的基本通信机制有三种实现策略</p>
<ul>
<li>话题通信（发布订阅模式）</li>
<li>服务通信（请求响应模式）</li>
<li>参数服务器（参数共享模式）</li>
</ul>
<h2 id="话题通信"><a href="#话题通信" class="headerlink" title="话题通信"></a>话题通信</h2><p>话题通信是基于<strong>发布订阅模式</strong>的，即一个节点发布消息，另一个结点订阅该消息，是ROS中使用频率最高的通信模式。例如如下场景：</p>
<blockquote>
<p>机器人在执行导航功能，使用的传感器是激光雷达，机器人会采集激光雷达感知到的信息并进行计算，然后生成运动控制信息驱动机器人的底盘</p>
</blockquote>
<p>在上述场景中，不止一次使用了话题通信</p>
<ul>
<li>激光雷达在采集信息并处理的时，ROS中有一个节点需要实时的发布当前雷达采集到的数据，导航模块中有结点会订阅并解析雷达数据。</li>
<li>在运动消息发布过程中，导航模块会根据传感器采集的数据实时计算出运动控制信息并发布给底盘，底盘也有一个节点订阅运动信息并转换成控制电机的脉冲信号。</li>
</ul>
<p>话题通信适用于不断更新的数据传输应用场景</p>
<h3 id="理论模型"><a href="#理论模型" class="headerlink" title="理论模型"></a>理论模型</h3><p>话题通信模型中涉及到的是那个角色</p>
<ul>
<li>ROS Master（管理者）</li>
<li>Talker（发布者）</li>
<li>Subscriber（订阅者）</li>
</ul>
<p>ROS Master负责管理Talker和Subscriber注册的信息，并匹配话题相同的Talker和Subscriber，帮助建立连接，在建立连接之后，Talker发布的信息可以被Subscriber订阅。<br><img src="/./img/ROSpictures/%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt="话题通信模型"></p>
<p>流程由一下步骤实现：</p>
<ul>
<li><p><strong>0)Talker注册</strong><br>Talker在启动后，会通过RPC（远程调用地址，即图中的”foo:1234”）在ROS Master中注册自身信息，其中包含所发布消息的话题名称。ROS Master会将节点的注册信息加入到注册表中。</p>
</li>
<li><p><strong>1)Subscriber注册</strong><br>Subscriber启动后，也会通过RPC在ROS Master中注册自身信息，包好需要订阅消息的话题名。ROS Master同样将节点注册信息加入到注册表中。</p>
</li>
<li><p><strong>2)ROS Master实现信息匹配</strong><br>ROS Master会根据注册表中的信息匹配Talker和Subscriber，并通过RPC向Subscriber发送Talker的RPC地址信息（图中的foo:1234）</p>
</li>
<li><p><strong>3)Subscriber向Talker发送请求</strong><br>Subscriber根据接收到的RPC地址，通过RPC向Talker发送连接请求，传输订阅的话题名称，消息类型以及通信协议（TCP&#x2F;UDP）。</p>
</li>
<li><p><strong>4)Talker确认请求</strong><br>Talker接受到Subscriber的请求后，也通过RPC向Subscriber确认连接信息，并发送自身的TCP地址信息（图中的TCP server:foo:2345）。</p>
</li>
<li><p><strong>5)Subscriber与Talker建立连接</strong><br>Subscriber根据上一步返回的消息使用TCP与Talker建立网络连接。</p>
</li>
<li><p><strong>6)Talker向Subscriber发送消息</strong><br>建立连接后，Talker开始向Subscriber发布消息</p>
</li>
</ul>
<blockquote>
<p>注意1：前5步通信过程中使用的是<strong>RPC协议</strong>，只有最后两步使用的是<strong>TCP协议</strong></p>
<p>注意2：Talker和Subscriber之间的启动无先后顺序要求</p>
<p>注意3：Talker和Subscriber都可以有多个</p>
<p>注意4：Talker和Subscriber之间建立连接后，就不再需要ROS Master。即使关闭ROS Master，也可以正常通信</p>
<p>注意5：上述的连接过程在ROS中已经封装好了，在具体实现过程中可以直接使用。</p>
</blockquote>
<h3 id="话题通信基本操作（C-）"><a href="#话题通信基本操作（C-）" class="headerlink" title="话题通信基本操作（C++）"></a>话题通信基本操作（C++）</h3><p>在具体实现过程中，ROS Master不需要实现，连接的建立也已经封装好了，需要注意的只有三点：</p>
<ul>
<li>发布方</li>
<li>接收方</li>
<li>数据</li>
</ul>
<p>流程：</p>
<ul>
<li>新建功能包</li>
<li>编写发布方实现</li>
<li>编写订阅方实现</li>
<li>编辑配置文件</li>
<li>编译并执行（C++代码需要先编译再执行）</li>
</ul>
<ol>
<li><p>新建功能包<br> 在工作区的src目录下新建功能包，比如我的工作目录为 ~&#x2F;catkin_ws&#x2F;src，可以在终端中首先进入src目录，然后新建一个功能包（可返回2.3查看）</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg test_pub_sub roscpp rospy std_msgs</span><br></pre></td></tr></table></figure>
<p> 通过上述命令新建一个名为 test_pub_sub 的功能包，其依赖项分别是 roscpp，rospy，std_msgs。</p>
<p> 之后新建发布者节点 pub_node.cpp文件，新建订阅者节点 sub_node.cpp文件</p>
</li>
<li><p>发布方代码（C++）<br> 编写发布方代码，其实有一个编写的框架，如下：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">发布方实现流程：</span></span><br><span class="line"><span class="comment">    1. 包含头文件</span></span><br><span class="line"><span class="comment">    2. 初始化 ROS 节点：命名（唯一）</span></span><br><span class="line"><span class="comment">    3. 实例化ROS Master（调用ROS大管家）</span></span><br><span class="line"><span class="comment">    4. 实例化 发布者对象</span></span><br><span class="line"><span class="comment">    5. 组织被发布的数据，编写逻辑，发布数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 编写头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ros/ros.h&gt;</span> <span class="comment">//或者写成 #include&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;std_msgs/String.h&gt;</span> <span class="comment">//普通文本类型的消息，也可以用&quot;&quot;引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置编码，是之可以显示中文</span></span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 初始化ROS节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;pub_node&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 实例化ROS Master</span></span><br><span class="line">    ros::NodeHandle nh; <span class="comment">//这里封装了ROS中的许多功能</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 实例化发布者对象；</span></span><br><span class="line">    ros::Publisher pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//这句代码中nh.advertise后的内容为：</span></span><br><span class="line">    <span class="comment">//&lt;发布的消息类型&gt;(&quot;发布到的话题名称&quot;, 队列中保存消息数的最大值)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 组织被发布的数据，编写逻辑，发布数据</span></span><br><span class="line">    std_msgs::String msg;   <span class="comment">//消息发布的载体</span></span><br><span class="line">    </span><br><span class="line">    std::String msg_front = <span class="string">&quot;Hello 你好！&quot;</span>;  <span class="comment">//消息前缀</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">//消息计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送频率</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">10</span>)</span> <span class="comment">//10Hz</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">whlie</span><span class="params">(ros::ok())</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用stringstream拼接字符串与编号</span></span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; msg_front &lt;&lt; count;</span><br><span class="line">        msg.data = ss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发布消息</span></span><br><span class="line">        pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">        <span class="comment">//打印发送的消息</span></span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;消息: %s&quot;</span>, msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="comment">//消息的内容在msg.data结构体的c_str()中。</span></span><br><span class="line"></span><br><span class="line">        r.<span class="built_in">sleep</span>();  <span class="comment">//根据之前设定的发送频率，进行休眠，休眠时间为1/频率</span></span><br><span class="line">        count++;    <span class="comment">//每次循环消息计数器+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅方代码（C++）<br> 与发布方类似，订阅方的大致框架如下</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">订阅方实现流程：</span></span><br><span class="line"><span class="comment">   1. 包含头文件</span></span><br><span class="line"><span class="comment">   2. 初始化 ROS 节点</span></span><br><span class="line"><span class="comment">   3. 实例化 ROS Master（即调用ROS大管家）</span></span><br><span class="line"><span class="comment">   4. 实例化订阅对象</span></span><br><span class="line"><span class="comment">   5. 处理订阅消息（需要编写回调函数）</span></span><br><span class="line"><span class="comment">   6. 设置循环调用回调函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 处理订阅消息（编写回调函数）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(std_msgs::String msg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;订阅消息：%s&quot;</span>, msg.data.<span class="built_in">c_str</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置编码格式</span></span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 初始化 ROS 节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;sub_node&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 实例化 ROS Master</span></span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 实例化 订阅者 对象</span></span><br><span class="line">    ros::Subscriber sub = nh.<span class="built_in">subscriber</span>&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>, <span class="number">10</span>, callback);</span><br><span class="line">    <span class="comment">//这句代码中nh.subscriber后的内容为：</span></span><br><span class="line">    <span class="comment">//&lt;发布的消息类型&gt;(&quot;发布到的话题名称&quot;, 队列中保存消息数的最大值, 回调函数名称)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 循环调用回调函数</span></span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())&#123;</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();    <span class="comment">//这里的spinOnce()可以让使在循环中的节点回过头检查是否有新消息包，防止节点错过消息包的接收。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ros::spin();  </span></span><br><span class="line">    <span class="comment">//除了上面的使用while循环之外，还可以使用spin()函数，循环读取接受的数据，并调用回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置CMakeList.txt文件<br> 在CMakeList.txt文件的结尾处添加编译规则和链接规则，不同的ROS版本，在添加时的写法可能有所不同，根据绿色字体的提示部分，进行编写，以我个人noetic（2022.10月版）版本为例（Ubuntu20.04）。</p>
 <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">add_executable(pub_node src/pub_node.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(pub_node</span><br><span class="line">    $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_executable(sub_node src/pub_node.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(sub_node</span><br><span class="line">    $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>执行</p>
<ol>
<li>首先编译代码<ul>
<li>可以在VSCode编译器的终端中使用Ctrl + shift + B 执行编译</li>
<li>在VSCode中可能出现问题导致无法编译，如果出现这种情况，可以打开一个终端，进入catkin_ws文件，使用指令<code>catkin_make</code>，对其目录下的所有文件进行编译，编写的代码如节点文件，message文件都在catkin_ws目录下的src文件中。</li>
</ul>
</li>
<li>运行roscore，运行发布者和订阅者节点</li>
</ol>
</li>
<li><p>注意：</p>
<ol>
<li>main函数声明时，<code>int main(int argc, char const *argv[])&#123;&#125;</code>有时默认argv被const修饰，需要<strong>删除const修饰</strong>。</li>
<li>订阅时，第一条数据丢失是因为publisher还未在roscore注册完毕。可以通过加入休眠<code>ros::Duration(3.0).sleep()</code>延迟第一条数据的发送。</li>
<li>如果出现No such file or directory等报错时，需要先确认CMakeList.txt文件中的相关配置是否出现问题。</li>
</ol>
</li>
</ol>
<h3 id="话题通信基本操作（python）"><a href="#话题通信基本操作（python）" class="headerlink" title="话题通信基本操作（python）"></a>话题通信基本操作（python）</h3><p>python的实现与C++基本类似，但细节上有些不同。</p>
<p>流程：</p>
<ul>
<li>新建功能包</li>
<li>编写发布方实现</li>
<li>编写订阅者实现</li>
<li>为py文件添加   可执行权限</li>
<li>编辑配置文件</li>
<li>执行</li>
</ul>
<ol>
<li><p>新建功能包<br> 进入工作空间catkin_ws的src子目录中<code>cd ~/catkin_ws/src/</code>，创建一个软件包<code>catkin_create_pkg test_pub_sub rospy std_msgs</code>，名为test_pub_sub，依赖项为rospy和std_msgs。<br> 在建好功能包之后，可以退回到catkin_ws工作空间，直接执行编译操作<code>catkin_make</code>，这样做的目的是为了让这个新建的包进入到ROS的软件包列表，以便后续运行时，ROS能在列表中找到这个包。当然后续再进行编译也是可以的。（这里编译操作不是在编译python文件，因为python代码不需要编译）。<br> 之后，在新建的包下，新建一个scripts文件夹，这个是用来装python节点的子目录。在scripts中新建节点文件，pub_node.py 和 sub_node.py。</p>
</li>
<li><p>编写发布方实现</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">流程：</span></span><br><span class="line"><span class="string">    1. 导包</span></span><br><span class="line"><span class="string">    2. 初始化 ROS 节点</span></span><br><span class="line"><span class="string">    3. 实例化 发布者 对象</span></span><br><span class="line"><span class="string">    4. 组织被发布的数据，编写逻辑，发布数据</span></span><br><span class="line"><span class="string">*/</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#按照py的惯例，第一行是python的解释器，Ubuntu20.04默认是python3的版本</span></span><br><span class="line"><span class="comment">#Coding = utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 导包</span></span><br><span class="line"><span class="keyword">import</span> rospy    <span class="comment">#在python中rospy就相当于与C++中的ROS大管家 ros::NodeHandle。</span></span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#2. 初始化ROS节点</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;pub_node&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#3. 实例化发布者对象</span></span><br><span class="line">    pub = rospy.Publisher(<span class="string">&quot;chatter&quot;</span>, String, queue_size = <span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 这里与C++不同，rospy.Publisher函数中的三个参数分别是 话题名称，话题中消息包的类型，消息包缓冲长度。写法相对于C++来说，更简单。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#4. 组织被发布的数据，编写逻辑，发布数据。</span></span><br><span class="line">    msg = String()  <span class="comment">#创建msg对象</span></span><br><span class="line">    msg_front = <span class="string">&quot;Hello 你好&quot;</span></span><br><span class="line">    count = <span class="number">0</span>       <span class="comment">#计数器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设置循环频率</span></span><br><span class="line">    rate = rospy.Rate(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        <span class="comment">#拼接字符串</span></span><br><span class="line">        msg.data = msg_front + <span class="built_in">str</span>(count)</span><br><span class="line"></span><br><span class="line">        pub.publish(msg)</span><br><span class="line">        rate.sleep()</span><br><span class="line">        rospy.loginfo(<span class="string">&quot;发布的数据：%s&quot;</span>, msg.data)</span><br><span class="line">        count += <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅方实现</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">流程：</span></span><br><span class="line"><span class="string">    1. 导包</span></span><br><span class="line"><span class="string">    2. 初始化 ROS 节点</span></span><br><span class="line"><span class="string">    3. 实例化 订阅者 对象</span></span><br><span class="line"><span class="string">    4. 处理订阅消息（编写回调函数）</span></span><br><span class="line"><span class="string">    5. 设置循环调用回调函数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#Coding = utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 导包</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="comment">#4. 编写回调函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;订阅信息：%s&quot;</span>, msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#2. 初始化 ROS 节点</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;sub_node&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#3. 实例化 订阅者 对象</span></span><br><span class="line">    sub = rospy.Subscriber(<span class="string">&quot;chatter&quot;</span>, String, callback, queue_size = <span class="number">10</span>)</span><br><span class="line">    <span class="comment">#rospy.Subscriber的四个参数分别是 话题名称，消息包类型，回调函数名，缓存队列长度。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#5. 设置循环调用毁掉函数</span></span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加可执行权限<br> 在终端中进入功能包的scripts目录，执行<code>chmod +x pub_node.py</code>，<code>chomd +x sub_node.py</code>。如果没有任何提示，说明权限添加成功。</p>
</li>
<li><p>配置CMakeLists.txt</p>
 <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">catkin_install_python(</span><br><span class="line">    scripts/pub_node.py</span><br><span class="line">    scripts/sub_node.py</span><br><span class="line">    DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行</p>
<ol>
<li>运行roscore</li>
<li>运行发布者节点，订阅者节点</li>
</ol>
</li>
</ol>
<h3 id="自定义话题通信的message"><a href="#自定义话题通信的message" class="headerlink" title="自定义话题通信的message"></a>自定义话题通信的message</h3><p>在ROS的通信协议中，数据载体是较为重要的组成部分，ROS中自带了许多针对不同使用场景的消息包，类似于std_msgs这样的数据包有非常的多。但是，当官方给出的消息包已经不能满足我们的需求时，可以自己定义新的消息类型。</p>
<p>msgs其实就是简单的文本文件，想要自定义一个消息包的主要流程如下：</p>
<ul>
<li>创建消息包</li>
<li>按照固定格式创建并编写msg文件</li>
<li>配置相关文件</li>
<li>编译生成可以被python或C++调用的中间文件</li>
</ul>
<ol>
<li><p>创建消息包<br> 在 catkin_ws&#x2F;src 路径下打开终端，使用<br> <code>catkin_create_pkg qq_msgs roscpp rospy message_generation message_runtime</code><br> 新建一个名为qq_msgs的功能包，其中的依赖项除了一直使用的 roscpp，rospy 之外，还包含了两个新的依赖项 <strong>message_generation</strong> 和 <strong>message_runtime</strong>，这两个是消息包生成和运行时所需要的依赖项。<br> 之后，在新创建的功能包中，创建一个新的目录 msg，在 msg 文件夹中创建一个新的.msg消息类型的文件，假设命名为 Person.msg。</p>
</li>
<li><p>编写msg文件<br> 格式可以参考ros.index中的消息类型，为 数据类型 变量名。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string name</span><br><span class="line">uini16 age</span><br><span class="line">float64 height</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写配置文件<br> <strong>CMakeLists.txt</strong>文件的配置<br> 确定CMakeLists.txt文件中有 message_generation 和 message_runtime</p>
 <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">    message_generation</span><br><span class="line">    message_runtime</span><br><span class="line">    roscpp</span><br><span class="line">    rospy</span><br><span class="line">    std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p> 取消add_message_files的注释，并更改其中的 .msg 文件为如下代码</p>
 <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_message_files(</span><br><span class="line">    FILES</span><br><span class="line">    Person.msg</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p> 取消generate_messages的注释，这句代码表明新的消息类型需要依赖的其他消息包列表，这里我们只用到了std_msgs中的数据类型，所以只添加一个std_msgs就够了</p>
 <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">generate_messages(</span><br><span class="line">    DEPENDENCIES</span><br><span class="line">    std_msgs</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 取消注释执行时的依赖项catkin_package</p>
 <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">    # INCLUDE_DIRS include</span><br><span class="line">    # LIBRARIES qq_msgs</span><br><span class="line">    CATKIN_DEPENDS message_generation message_runtime roscpp rospy std_msgs</span><br><span class="line">    # DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p> <strong>package.xml</strong>文件的配置<br> 在package.xml文件的依赖项列表中添加编译依赖和执行依赖，确保 build_depend 和 exec_depend 都列出了 message_generation 和 message_runtime。缺失的话就补全</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">·</span><br><span class="line">·</span><br><span class="line">·</span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译<br> 在工作空中执行catkin_make，没有报错则编译成功<br> 检查是否进入ROS的消息列表：执行 <code>rosmsg show qq_msgs/Person</code>，如果能看到消息类型的显示，与自定义的结构一样，则成功。</p>
</li>
</ol>
<h2 id="服务通信"><a href="#服务通信" class="headerlink" title="服务通信"></a>服务通信</h2><p>服务通信也是ROS中常用的通信模式，是基于请求响应模式的，是一种应答机制。例如，一个节点需要向相机节点发送拍照请求，相机节点处理请求，并返回处理结果。因此服务通信更适合于对实时性有要求，具有一定的逻辑处理的应用场景。相比话题通信，服务通信模型更简单。</p>
<ul>
<li>服务通信是以请求响应的方式实现不同节点之间数据交互的通信模式。</li>
<li>用于偶然的，对实施性有要求，有一定逻辑处理需求的数据传输场景</li>
</ul>
<h3 id="服务通信的理论模型"><a href="#服务通信的理论模型" class="headerlink" title="服务通信的理论模型"></a>服务通信的理论模型</h3><p>服务通信涉及到的角色有三个</p>
<ul>
<li>ROS Master（管理员）</li>
<li>Server（服务器）</li>
<li>Client（客户端）</li>
</ul>
<p>ROS Master负责保管Server和Client的注册信息，并匹配话题相同的Server和Client，帮助两者建立连接，之后Client发送请求信息，Server返回响应信息。<br><img src="/./img/ROSpictures/%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt="服务通信模型"></p>
<ul>
<li><strong>0)Server注册</strong><br>Server启动后，会通过RPC在ROS Master中注册自身信息，其中包含提供的服务名称。ROS Master会将节点的注册信息加入到注册表中。</li>
<li><strong>1)Client注册</strong><br>Client启动后，也会通过RPC在ROS Master中注册自身信息，包含需要的请求的服务的名称。ROS Master会将节点的注册信息加入到注册表中。</li>
<li><strong>2)ROS Master实现信息匹配</strong><br>ROS Master会根据注册表中的信息匹配Server和Client，并通过RPC想Client发送Server的TCP地址信息。</li>
<li><strong>3)Client发送请求</strong><br>Client根据步骤2的响应信息，使用TCP与Server建立网络连接，并发送请求数据。</li>
<li><strong>4)Server发送响应</strong><br>Server接受，解析请求数据，并产生响应结果返回给Client。<blockquote>
<p>注意1：Client的请求被处理时，确保Server已启动。</p>
<p>注意2：Server和Client可以存在多个</p>
</blockquote>
</li>
</ul>
<h3 id="服务通信自定义srv"><a href="#服务通信自定义srv" class="headerlink" title="服务通信自定义srv"></a>服务通信自定义srv</h3><p>假设有这样一个需求，客户端提交两个整数到服务端，服务端求和并响应结果到客户端，我们需要创建这样的一个数据载体。</p>
<p>srv与话题通信中的msg的可用数据类型一致，实现流程也类似：</p>
<ul>
<li>按照固定格式创建srv文件</li>
<li>编辑配置文件</li>
<li>编译生成中间文件</li>
</ul>
<ol>
<li><p>定义srv文件<br>服务通信中，数据分成两部分，<strong>请求</strong>和<strong>响应</strong>，在srv文件中请求和响应的数据使用<code>---</code>分隔符进行分隔。具体步骤为：先在功能包中新建一个srv目录，添加要编写的 xxx.srv 文件，文件的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 客户端请求时发送的两个数字</span><br><span class="line">int32 num1</span><br><span class="line">int32 num2</span><br><span class="line">---</span><br><span class="line"># 服务器响应发送的数据</span><br><span class="line">int32 sum</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑配置文件<br>package.xml中添加<strong>编译依赖</strong>和<strong>执行依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>CMakeLists.txt编辑 srv 相关配置</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br><span class="line"># 需要加入 message_generation,必须有 std_msgs</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_service_files(</span><br><span class="line">  FILES</span><br><span class="line">  xxx.srv</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catkin_package(</span><br><span class="line">    CATKIN_DEPENDS roscpp rospy std_msgs message_runtime</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在这里catkin_package中配置的是find_package中的依赖包的依赖包，官网中没有配置，但在这里配置了也没有问题。</p>
</blockquote>
<h2 id="参数服务器"><a href="#参数服务器" class="headerlink" title="参数服务器"></a>参数服务器</h2><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://karsonkang.github.io">Karson Kang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://karsonkang.github.io/2022/10/06/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://karsonkang.github.io/2022/10/06/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://karsonkang.github.io" target="_blank">Karson Kang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ROS-Ubuntu/">-ROS -Ubuntu</a></div><div class="post_share"><div class="social-share" data-image="/./img/ROS-noetic.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/06/Fusion%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="/./img/Fusion-img.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Fusion学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/25/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="/./img/leetcode.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">leetcode刷题笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Ubuntu%E7%BB%88%E7%AB%AF%E7%AA%97%E5%8F%A3%E5%91%BD%E4%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">Ubuntu终端窗口命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.</span> <span class="toc-text">基础指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8gedit"><span class="toc-number">1.2.</span> <span class="toc-text">文本编辑器gedit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#source%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.</span> <span class="toc-text">source指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC-x2F-bashrc"><span class="toc-number">1.4.</span> <span class="toc-text">终端程启动脚本 ~&#x2F;.bashrc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sudo%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.</span> <span class="toc-text">sudo指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ROS%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">ROS系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ROS%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.1.</span> <span class="toc-text">ROS安装步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APT%E6%BA%90%EF%BC%8CROS%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97"><span class="toc-number">2.2.</span> <span class="toc-text">APT源，ROS的软件包应用商店</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ROS%E6%9E%B6%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">ROS架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ROS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">2.4.</span> <span class="toc-text">ROS文件系统相关命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ROS%E8%AE%A1%E7%AE%97%E5%9B%BErqt-graph"><span class="toc-number">2.5.</span> <span class="toc-text">ROS计算图rqt_graph</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ROS%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">ROS通信机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1"><span class="toc-number">3.1.</span> <span class="toc-text">话题通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">理论模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88C-%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">话题通信基本操作（C++）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88python%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">话题通信基本操作（python）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1%E7%9A%84message"><span class="toc-number">3.1.4.</span> <span class="toc-text">自定义话题通信的message</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1"><span class="toc-number">3.2.</span> <span class="toc-text">服务通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E7%9A%84%E7%90%86%E8%AE%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">服务通信的理论模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%80%9A%E4%BF%A1%E8%87%AA%E5%AE%9A%E4%B9%89srv"><span class="toc-number">3.2.2.</span> <span class="toc-text">服务通信自定义srv</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">参数服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.4.</span> <span class="toc-text">常用命令</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/ROS-noetic.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Karson Kang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my <a target="_blank" rel="noopener" href="https://karsonkan.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>